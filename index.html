<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="JavaScript interview flashcards for testers - Learn JS concepts for test automation">
    <meta name="theme-color" content="#f97316">
    <title>JavaScript Interview Flashcards for Testers</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS Support -->
    <link rel="apple-touch-icon" href="icon-192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="JS Flashcards">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="icon-192.png">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        .perspective-1000 {
            perspective: 1000px;
        }
        .transform-style-3d {
            transform-style: preserve-3d;
        }
        .backface-hidden {
            backface-visibility: hidden;
        }
        .rotate-y-180 {
            transform: rotateY(180deg);
        }
        
        /* Install prompt styling */
        .install-prompt {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from {
                transform: translateX(-50%) translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <!-- Install Prompt -->
    <div id="install-prompt" style="display: none;" class="install-prompt">
        <div class="bg-orange-500 text-white px-6 py-4 rounded-xl shadow-2xl flex items-center gap-4 max-w-md">
            <div class="flex-1">
                <p class="font-semibold">Install App</p>
                <p class="text-sm text-orange-100">Add to home screen for quick access</p>
            </div>
            <button id="install-button" class="bg-white text-orange-500 px-4 py-2 rounded-lg font-semibold hover:bg-orange-50">
                Install
            </button>
            <button id="dismiss-button" class="text-orange-100 hover:text-white">
                âœ•
            </button>
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const interviewQuestions = [
            {
                category: "Basics",
                question: "What is JavaScript and why is it important for test automation?",
                answer: "JavaScript is a programming language that runs in browsers and on servers (Node.js). It's important for testers because: 1) Most modern test automation tools (Playwright, Cypress, WebdriverIO) use JavaScript. 2) You can write both frontend and backend tests. 3) It's the language of the web, making it essential for web testing. 4) Large community and extensive testing libraries available."
            },
            {
                category: "Basics",
                question: "What is the difference between var, let, and const?",
                answer: "var: Function-scoped, can be redeclared and updated, hoisted. let: Block-scoped, cannot be redeclared but can be updated, not hoisted. const: Block-scoped, cannot be redeclared or updated (but object properties can change), not hoisted. Best practice: Use const by default, let when you need to reassign, avoid var."
            },
            {
                category: "Basics",
                question: "What are the different data types in JavaScript?",
                answer: "Primitive types: String, Number, Boolean, Undefined, Null, Symbol, BigInt. Reference type: Object (includes Arrays, Functions, Dates, etc.). You can check types using typeof operator. Example: typeof 'hello' returns 'string'."
            },
            {
                category: "Async",
                question: "What is the difference between synchronous and asynchronous code?",
                answer: "Synchronous: Code executes line by line, blocking execution until complete. Example: console.log('A'); console.log('B'); Asynchronous: Code doesn't block, allows other operations while waiting. Example: setTimeout, API calls, file reading. Critical for test automation as tests often wait for elements, page loads, or API responses."
            },
            {
                category: "Async",
                question: "What are Promises and why are they important in testing?",
                answer: "A Promise is an object representing eventual completion or failure of an async operation. States: Pending, Fulfilled, Rejected. Used extensively in test automation for: Waiting for page loads, API responses, element visibility. Example: await page.goto('url') returns a promise. Can be chained with .then() or used with async/await syntax."
            },
            {
                category: "Async",
                question: "What is async/await and how is it used in test automation?",
                answer: "async/await is syntactic sugar over Promises, making async code look synchronous. async: Declares a function returns a Promise. await: Pauses execution until Promise resolves. Essential in testing: await page.click('#button'); await expect(element).toBeVisible(); Makes test code more readable and easier to maintain."
            },
            {
                category: "DOM",
                question: "How do you select elements in JavaScript for testing?",
                answer: "Methods: document.getElementById('id'), document.querySelector('.class'), document.querySelectorAll('div'), document.getElementsByClassName('name'). Modern frameworks use: Playwright: page.locator('#id'), Cypress: cy.get('.class'). Best practice: Use data-testid attributes for reliable selection."
            },
            {
                category: "DOM",
                question: "How do you wait for elements in test automation?",
                answer: "Explicit waits (preferred): await page.waitForSelector('#element'), await element.waitFor({state: 'visible'}). Implicit waits: Set default timeout. Conditional waits: await page.waitForFunction(() => document.readyState === 'complete'). Avoid: Hard waits like sleep() - they're unreliable and slow tests down."
            },
            {
                category: "Functions",
                question: "What is the difference between function declaration and arrow function?",
                answer: "Function declaration: function test() {} - Has 'this' context, can be hoisted. Arrow function: const test = () => {} - Inherits 'this' from parent, cannot be hoisted, more concise. In testing: Arrow functions are common in callbacks and test blocks. Example: it('should login', async () => { await page.click() });"
            },
            {
                category: "Functions",
                question: "What are callback functions and why are they used in testing?",
                answer: "A callback is a function passed as an argument to another function, executed after an operation completes. Common in testing: test('name', async () => {}), array.forEach((item) => {}), element.addEventListener('click', () => {}). Used for: Test definitions, handling async operations, event listeners, array iterations."
            },
            {
                category: "Arrays",
                question: "What array methods are most useful for testers?",
                answer: "map(): Transform array elements. filter(): Get elements matching condition. find(): Get first matching element. forEach(): Iterate over elements. some(): Check if any element matches. every(): Check if all elements match. Example: const names = elements.map(el => el.textContent); const visible = elements.filter(el => el.isVisible());"
            },
            {
                category: "Arrays",
                question: "How do you work with multiple elements in test automation?",
                answer: "Get all elements: const elements = await page.$$('.item'); Iterate: for(const el of elements) { await el.click() }; Count: expect(elements.length).toBe(5); Filter: const visible = elements.filter(async el => await el.isVisible()); Map text: const texts = await Promise.all(elements.map(el => el.textContent()));"
            },
            {
                category: "Objects",
                question: "How do you work with objects in JavaScript testing?",
                answer: "Create: const user = {name: 'John', email: 'john@test.com'}; Access: user.name or user['email']; Add property: user.age = 30; Destructure: const {name, email} = user; In testing: Used for test data, page objects, configuration. Example: const {username, password} = testData.validUser;"
            },
            {
                category: "Objects",
                question: "What is object destructuring and where is it used in testing?",
                answer: "Extracting properties from objects into variables. Syntax: const {name, age} = person; With arrays: const [first, second] = array; In testing: Extracting test data: const {username, password} = credentials; Extracting from responses: const {status, data} = await response.json(); Makes code cleaner and more readable."
            },
            {
                category: "Error Handling",
                question: "How do you handle errors in test automation?",
                answer: "try-catch blocks: try { await page.click('#btn') } catch(error) { console.log('Click failed') }; Assertions: expect(element).toBeVisible(); Promise rejection: .catch() or try-catch with await. In tests: Used for handling flaky elements, verifying error messages, cleanup in finally block. Always fail tests explicitly when unexpected errors occur."
            },
            {
                category: "Error Handling",
                question: "What is the purpose of try-catch-finally in testing?",
                answer: "try: Execute test code that might fail. catch: Handle errors, log info, take screenshots. finally: Cleanup code that runs regardless (close browsers, delete test data). Example: try { await test() } catch(err) { await screenshot() } finally { await browser.close() }. Critical for reliable test cleanup and debugging."
            },
            {
                category: "Testing Concepts",
                question: "What is the difference between == and === in JavaScript?",
                answer: "==: Loose equality, performs type coercion. Example: '5' == 5 is true. ===: Strict equality, checks type and value. Example: '5' === 5 is false. Best practice in testing: Always use === to avoid unexpected behavior. Same applies to != vs !==. Assertions typically use strict equality."
            },
            {
                category: "Testing Concepts",
                question: "What are template literals and how are they useful in testing?",
                answer: "Template literals use backticks (`) and allow: String interpolation: `Hello ${name}`; Multi-line strings; Expression evaluation. In testing: Dynamic selectors: `[data-testid='user-${id}']`; Error messages: `Expected ${expected} but got ${actual}`; Dynamic URLs: `${baseURL}/users/${userId}`."
            },
            {
                category: "Automation",
                question: "What is Page Object Model (POM) and how is it implemented in JavaScript?",
                answer: "POM is a design pattern where each page is represented as a class/object. Benefits: Reusability, maintainability, reduces code duplication. Implementation: class LoginPage { async login(user, pass) { await this.usernameInput.fill(user) } }. Separates test logic from page interactions. Makes tests easier to update when UI changes."
            },
            {
                category: "Automation",
                question: "How do you handle multiple browser windows/tabs in test automation?",
                answer: "Get all pages: const pages = context.pages(); Switch context: await page.bringToFront(); Handle new windows: const newPage = await context.waitForEvent('page'); Close: await page.close(); Get by URL: const page = pages.find(p => p.url().includes('login')). Important for testing popups, multi-tab workflows, OAuth flows."
            },
            {
                category: "Automation",
                question: "What are CSS selectors and XPath? When to use each?",
                answer: "CSS Selectors: Faster, easier to read. Examples: '#id', '.class', 'div > p'. XPath: More powerful, can traverse up DOM. Examples: '//div[@id='test']', '//button[text()='Submit']'. Use CSS when: Simple selection, performance matters. Use XPath when: Need text matching, traverse to parent, complex conditions. Modern tools prefer CSS/test IDs."
            },
            {
                category: "API Testing",
                question: "How do you make API calls in JavaScript testing?",
                answer: "Using fetch: const response = await fetch(url, {method: 'POST', body: JSON.stringify(data)}); Using axios: const response = await axios.get(url); Playwright API: const response = await request.post(url, {data}); Check status: expect(response.status).toBe(200); Parse JSON: const data = await response.json(); Essential for API testing and test data setup."
            },
            {
                category: "API Testing",
                question: "How do you validate API responses in JavaScript?",
                answer: "Status code: expect(response.status).toBe(200); Headers: expect(response.headers['content-type']).toContain('json'); Body structure: expect(data).toHaveProperty('id'); Data types: expect(typeof data.name).toBe('string'); Arrays: expect(data.users).toHaveLength(5); Nested objects: expect(data.user.email).toBe('test@test.com');"
            },
            {
                category: "Best Practices",
                question: "What are some JavaScript best practices for test automation?",
                answer: "1) Use const/let, avoid var. 2) Use async/await instead of callbacks. 3) Implement Page Object Model. 4) Use descriptive variable/function names. 5) Add proper waits, avoid hard sleeps. 6) Handle errors with try-catch. 7) Use data-testid for selectors. 8) Keep tests independent. 9) Clean up test data. 10) Use beforeEach/afterEach for setup/teardown."
            },
            {
                category: "Best Practices",
                question: "How do you debug JavaScript test automation code?",
                answer: "Console.log: console.log('Element:', element); Debugger: Add 'debugger' statement, run with --inspect. Screenshots: await page.screenshot({path: 'debug.png'}); Video recording: Enable in test config. Browser DevTools: Use page.pause() in Playwright. Verbose logging: Run tests with --verbose. Check element state: console.log(await element.isVisible());"
            },
            {
                category: "Frameworks",
                question: "What are the popular JavaScript testing frameworks?",
                answer: "Test runners: Jest, Mocha, Jasmine. Automation tools: Playwright, Cypress, WebdriverIO, Puppeteer. Assertion libraries: Chai, Jest (built-in). Each has strengths: Playwright - Fast, reliable, multi-browser. Cypress - Great DX, real-time reload. Jest - Unit/integration testing. Choose based on: project needs, team skills, browser support requirements."
            },
            {
                category: "Frameworks",
                question: "What is the structure of a typical test in JavaScript?",
                answer: "describe('Feature name', () => { beforeEach(() => { /* setup */ }); test('should do something', async () => { /* arrange */ const page = await browser.newPage(); /* act */ await page.click('#button'); /* assert */ expect(result).toBe(expected); }); afterEach(() => { /* cleanup */ }); }); This follows AAA pattern: Arrange, Act, Assert."
            }
        ];

        const ChevronLeft = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
        );

        const ChevronRight = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
        );

        const Shuffle = () => (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="16 3 21 3 21 8"></polyline>
                <line x1="4" y1="20" x2="21" y2="3"></line>
                <polyline points="21 16 21 21 16 21"></polyline>
                <line x1="15" y1="15" x2="21" y2="21"></line>
                <line x1="4" y1="4" x2="9" y2="9"></line>
            </svg>
        );

        const RotateCcw = () => (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="1 4 1 10 7 10"></polyline>
                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
            </svg>
        );

        const Filter = () => (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
            </svg>
        );

        function FlashcardApp() {
            const [cards, setCards] = useState(interviewQuestions);
            const [currentIndex, setCurrentIndex] = useState(0);
            const [isFlipped, setIsFlipped] = useState(false);
            const [progress, setProgress] = useState({});
            const [selectedCategory, setSelectedCategory] = useState('All');
            const [showCategoryMenu, setShowCategoryMenu] = useState(false);

            const categories = ['All', ...new Set(interviewQuestions.map(q => q.category))];

            useEffect(() => {
                try {
                    const saved = localStorage.getItem('js-flashcard-progress');
                    if (saved) {
                        setProgress(JSON.parse(saved));
                    }
                } catch (e) {
                    console.log('Could not load progress');
                }
            }, []);

            useEffect(() => {
                if (selectedCategory === 'All') {
                    setCards(interviewQuestions);
                } else {
                    setCards(interviewQuestions.filter(q => q.category === selectedCategory));
                }
                setCurrentIndex(0);
                setIsFlipped(false);
            }, [selectedCategory]);

            const saveProgress = (newProgress) => {
                setProgress(newProgress);
                try {
                    localStorage.setItem('js-flashcard-progress', JSON.stringify(newProgress));
                } catch (e) {
                    console.log('Could not save progress');
                }
            };

            const handleFlip = () => {
                setIsFlipped(!isFlipped);
            };

            const handleNext = () => {
                setIsFlipped(false);
                setCurrentIndex((prev) => (prev + 1) % cards.length);
            };

            const handlePrevious = () => {
                setIsFlipped(false);
                setCurrentIndex((prev) => (prev - 1 + cards.length) % cards.length);
            };

            const handleShuffle = () => {
                const shuffled = [...cards].sort(() => Math.random() - 0.5);
                setCards(shuffled);
                setCurrentIndex(0);
                setIsFlipped(false);
            };

            const handleReset = () => {
                setCards(interviewQuestions);
                setCurrentIndex(0);
                setIsFlipped(false);
                setSelectedCategory('All');
                saveProgress({});
            };

            const markAsKnown = () => {
                const cardKey = cards[currentIndex].question;
                const newProgress = { ...progress, [cardKey]: true };
                saveProgress(newProgress);
                handleNext();
            };

            const currentCard = cards[currentIndex];
            const knownCount = Object.values(progress).filter(Boolean).length;

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-orange-50 flex flex-col items-center justify-center p-4">
                    <div className="w-full max-w-2xl">
                        <div className="text-center mb-6">
                            <h1 className="text-3xl font-bold text-gray-800 mb-2">
                                ðŸ’» JavaScript Interview Questions
                            </h1>
                            <p className="text-gray-600">For Test Automation Engineers</p>
                        </div>

                        <div className="mb-4 flex justify-between items-center flex-wrap gap-2">
                            <div className="text-sm text-gray-600">
                                Card {currentIndex + 1} of {cards.length}
                            </div>
                            <div className="flex gap-2 items-center">
                                <span className="bg-green-100 px-3 py-1 rounded-full text-sm">
                                    Known: {knownCount}/{interviewQuestions.length}
                                </span>
                                <div className="relative">
                                    <button
                                        onClick={() => setShowCategoryMenu(!showCategoryMenu)}
                                        className="bg-orange-500 text-white px-3 py-1 rounded-full text-sm flex items-center gap-1 hover:bg-orange-600"
                                    >
                                        <Filter />
                                        {selectedCategory}
                                    </button>
                                    {showCategoryMenu && (
                                        <div className="absolute right-0 mt-2 bg-white rounded-lg shadow-xl border border-gray-200 py-2 z-50 min-w-[150px]">
                                            {categories.map(cat => (
                                                <button
                                                    key={cat}
                                                    onClick={() => {
                                                        setSelectedCategory(cat);
                                                        setShowCategoryMenu(false);
                                                    }}
                                                    className={`w-full text-left px-4 py-2 hover:bg-gray-100 ${
                                                        selectedCategory === cat ? 'bg-orange-50 text-orange-600 font-semibold' : 'text-gray-700'
                                                    }`}
                                                >
                                                    {cat}
                                                </button>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>

                        <div className="mb-3">
                            <span className="inline-block bg-blue-100 text-blue-700 px-3 py-1 rounded-full text-sm font-medium">
                                {currentCard.category}
                            </span>
                        </div>

                        <div 
                            className="relative h-96 mb-6 perspective-1000 cursor-pointer"
                            onClick={handleFlip}
                        >
                            <div 
                                className={`absolute w-full h-full transition-transform duration-500 transform-style-3d ${
                                    isFlipped ? 'rotate-y-180' : ''
                                }`}
                            >
                                <div className="absolute w-full h-full backface-hidden bg-white rounded-2xl shadow-2xl flex flex-col items-center justify-center p-8 border-4 border-blue-400">
                                    <div className="text-sm text-gray-500 mb-4">QUESTION</div>
                                    <div className="text-2xl font-bold text-gray-800 text-center">
                                        {currentCard.question}
                                    </div>
                                    <div className="mt-8 text-gray-400 text-sm">Tap to reveal answer</div>
                                </div>
                                
                                <div className="absolute w-full h-full backface-hidden bg-gradient-to-br from-orange-500 to-orange-600 rounded-2xl shadow-2xl flex flex-col items-center justify-center p-8 border-4 border-orange-700 rotate-y-180 overflow-y-auto">
                                    <div className="text-sm text-orange-100 mb-4">ANSWER</div>
                                    <div className="text-lg text-white text-left leading-relaxed">
                                        {currentCard.answer}
                                    </div>
                                    <div className="mt-6 text-orange-100 text-sm">Tap to flip back</div>
                                </div>
                            </div>
                        </div>

                        <div className="flex gap-3 mb-6">
                            <button
                                onClick={handlePrevious}
                                className="flex-1 bg-white hover:bg-gray-50 text-gray-700 py-3 px-4 rounded-xl shadow-md transition-all flex items-center justify-center gap-2 font-medium"
                            >
                                <ChevronLeft />
                                Previous
                            </button>
                            <button
                                onClick={handleNext}
                                className="flex-1 bg-white hover:bg-gray-50 text-gray-700 py-3 px-4 rounded-xl shadow-md transition-all flex items-center justify-center gap-2 font-medium"
                            >
                                Next
                                <ChevronRight />
                            </button>
                        </div>

                        {isFlipped && (
                            <button
                                onClick={markAsKnown}
                                className="w-full bg-green-500 hover:bg-green-600 text-white py-3 px-4 rounded-xl shadow-md transition-all mb-6 font-medium"
                            >
                                âœ“ I know this one
                            </button>
                        )}

                        <div className="flex gap-3">
                            <button
                                onClick={handleShuffle}
                                className="flex-1 bg-orange-500 hover:bg-orange-600 text-white py-3 px-4 rounded-xl shadow-md transition-all flex items-center justify-center gap-2 font-medium"
                            >
                                <Shuffle />
                                Shuffle
                            </button>
                            <button
                                onClick={handleReset}
                                className="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-3 px-4 rounded-xl shadow-md transition-all flex items-center justify-center gap-2 font-medium"
                            >
                                <RotateCcw />
                                Reset
                            </button>
                        </div>

                        <div className="mt-6 text-center text-sm text-gray-500">
                            Progress is saved automatically â€¢ Works offline
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<FlashcardApp />);
    </script>

    <!-- Service Worker Registration -->
    <script>
        // Register service worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('ServiceWorker registered:', registration.scope);
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed:', err);
                    });
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        const installPrompt = document.getElementById('install-prompt');
        const installButton = document.getElementById('install-button');
        const dismissButton = document.getElementById('dismiss-button');

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // Check if user has already dismissed
            const dismissed = localStorage.getItem('install-prompt-dismissed');
            if (!dismissed) {
                installPrompt.style.display = 'block';
            }
        });

        installButton.addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response: ${outcome}`);
                deferredPrompt = null;
                installPrompt.style.display = 'none';
            }
        });

        dismissButton.addEventListener('click', () => {
            installPrompt.style.display = 'none';
            localStorage.setItem('install-prompt-dismissed', 'true');
        });

        // Log when app is installed
        window.addEventListener('appinstalled', () => {
            console.log('PWA was installed');
            installPrompt.style.display = 'none';
        });
    </script>
</body>
</html>
